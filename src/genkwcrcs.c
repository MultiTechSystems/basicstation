/*
 * --- Revised 3-Clause BSD License ---
 * Copyright Semtech Corporation 2022. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice,
 *       this list of conditions and the following disclaimer in the documentation
 *       and/or other materials provided with the distribution.
 *     * Neither the name of the Semtech corporation nor the names of its
 *       contributors may be used to endorse or promote products derived from this
 *       software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL SEMTECH CORPORATION. BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#if defined(CFG_prog_genkwcrcs)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "uj.h"

#define P1 257
#define P2 65537
#define SC (32-8)

#define FINISH_CRC(crc)    X((crc) ? (crc) : 1)
#define UPDATE_CRC(crc, c) X((((crc)>>SC)*P2) ^ ((crc)*P1) ^ ((c)&0x7F))
#define STR(expr) CAT(XXX,expr)
#define STR2(p) #p
#define CAT(p, ...) STR2(p ##__VA_ARGS__)

#define MAX_KEYWORDS 1024
#define MAX_KEYWORD_LEN 256

ujcrc_t X(ujcrc_t x) {
    return x;
}

ujcrc_t calcCRC(const char* s) {
    ujcrc_t crc = 0;
    int c;
    while( (c=*s++) ) {
        crc = UPDATE_CRC(crc,c);
    }
    return FINISH_CRC(crc);
}

void output_keywords(char** keywords, ujcrc_t* crcs, int count) {
    printf("// Auto generated by genkwcrcs - DO NOT CHANGE!\n");
    printf("#define UJ_UPDATE_CRC(crc,c) %s\n", 4+STR(UPDATE_CRC(crc,c)));
    printf("#define UJ_FINISH_CRC(crc)   %s\n", 4+STR(FINISH_CRC(crc)));
    for( int i=0; i<count; i++ ) {
        char ident[MAX_KEYWORD_LEN];
        int cj = 0;
        for( cj=0; keywords[i][cj]; cj++ ) {
            char c = keywords[i][cj];
            ident[cj] = (c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') ? c : '_';
        }
        ident[cj] = 0;
        printf("#define J_%-20s ((ujcrc_t)(0x%08X))\n", ident, crcs[i]);
    }
}

int check_collision(char** keywords, ujcrc_t* crcs, int idx) {
    for( int j=idx-1; j>=0; j-- ) {
        if( crcs[j] == crcs[idx] && strcmp(keywords[j], keywords[idx]) != 0 ) {
            fprintf(stderr, "Collision: %s(0x%X) vs %s(0x%X)\n",
                    keywords[idx], crcs[idx], keywords[j], crcs[j]);
            return 1;
        }
    }
    return 0;
}

int main (int argc, char** argv) {
    char* keywords[MAX_KEYWORDS];
    ujcrc_t crcs[MAX_KEYWORDS];
    int count = 0;

    if( argc > 1 ) {
        // Command line arguments mode (original behavior)
        argv++;
        argc--;
        for( int i=0; i<argc && count<MAX_KEYWORDS; i++ ) {
            keywords[count] = argv[i];
            crcs[count] = calcCRC(argv[i]);
            if( check_collision(keywords, crcs, count) )
                exit(1);
            count++;
        }
    } else {
        // Stdin mode - read keywords from stdin, one per line
        static char linebuf[MAX_KEYWORDS][MAX_KEYWORD_LEN];
        char line[MAX_KEYWORD_LEN];
        while( fgets(line, sizeof(line), stdin) && count < MAX_KEYWORDS ) {
            // Strip newline and whitespace
            int len = strlen(line);
            while( len > 0 && (line[len-1] == '\n' || line[len-1] == '\r' || line[len-1] == ' ') )
                line[--len] = 0;
            // Skip empty lines and comments
            if( len == 0 || line[0] == '#' )
                continue;
            strcpy(linebuf[count], line);
            keywords[count] = linebuf[count];
            crcs[count] = calcCRC(keywords[count]);
            if( check_collision(keywords, crcs, count) )
                exit(1);
            count++;
        }
    }

    output_keywords(keywords, crcs, count);
    return 0;
}

#endif // defined(CFG_prog_genkwcrcs)
